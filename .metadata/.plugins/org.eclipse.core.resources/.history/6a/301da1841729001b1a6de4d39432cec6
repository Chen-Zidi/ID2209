/**
* Name: task1
* Based on the internal empty template. 
* Author: czdpa
* Tags: 
*/


model task1

global
{
	
	int number_of_queens <- 2;
	list<Queen> queenList;
	int col <- 0;
	init
	{
		create Queen number: number_of_queens
		{
			location <- QueenGrid[col,0].location;
			col <- col + 1;
			
			//set the predecessor
			if(length(queenList) > 0)
			{
				
				self.predecessor <- queenList[length(queenList) - 1];
				
//				write "me"+self;
//				write "predecessor"+self.predecessor;

				//set the successor
				queenList[length(queenList) - 1].successor <- self;
			}
			
			
			queenList << self;
			
		}
		
		
		ask queenList[0] {
			self.column <- 0;
			self.row <- 0;
			self.placed <- true;
			do informSuccessorMyPosition();
		}
		
		
	}
	
}

grid QueenGrid width: 3 height: 3 {
	rgb color <- bool(((grid_x + grid_y) mod 2)) ? #black : #white;
}

species Queen skills:[fipa,moving]
{
	int column;
	int row;
	point myPlace;
	//to identify if myself is placed
	bool placed <- false;
	Queen predecessor <- nil;
	Queen successor <- nil;
	
	//to store the locations of grids which already have queens
	list<point> filledGrids;

	action placeMyPosition
	{
		//generate all positions of grids
		list<point> possiblePosition;
		
		loop i from: 0 to: 3 step: 1
		{
			loop j from: 0 to: 3 step: 1
			{
				possiblePosition << {i, j};
			}
		}
		
		//remove the positions which are not available
		loop p over:possiblePosition
		{
			loop fg over:filledGrids
			{
				if ((fg.x = p.x) or (fg.y = p.y) or ((p.y - fg.y) = (p.x - fg.x)))
				{
					remove p from: possiblePosition;
				}
					
			}
		}
		
		write possiblePosition;
		
//		int temp <- rnd(0,length(possiblePosition)-1);
//		row <- possiblePosition[temp].x;
//		column <- possiblePosition[temp].y;
		
	}
	
	action informSuccessorMyPosition
	{
		filledGrids << {column, row};
		do start_conversation to: [successor] protocol: 'no-protocol' performative: 'inform' contents: [row,column];
	}
	
//	reflex gotoMyPosition when: row != nil and column != nil and !placed
//	{
//		myPlace <- QueenGrid[column,row].location;
//		write "my grid: "+ self + " ["+row+", "+column+"]";
//		do goto target: myPlace;
//	}
//	
//	reflex reachMyPosition when: location distance_to myPlace < 0.2 and row != nil and column != nil and !placed
//	{
//		placed <- true;
//		write "I arrived!";
//	}
	
	reflex receivePredecessorPosition when: !(empty(informs))
	{
		Queen sender <- informs[0].sender;
		ask sender
		{
			
			loop fg over:self.filledGrids
			{
				myself.filledGrids << fg;
			}
		}
		do placeMyPosition;
	}
	
	aspect base
	{
		draw sphere(2) color: #yellow;
	}
}

experiment main type:gui
{
	output
	{
		display map type:opengl
		{
			
			species Queen aspect:base;
			grid QueenGrid lines:#black;
		}
	}
	
}
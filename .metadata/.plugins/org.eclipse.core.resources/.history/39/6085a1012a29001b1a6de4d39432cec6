/**
* Name: task1
* Based on the internal empty template. 
* Author: czdpa
* Tags: 
*/


model task1

global
{
	
	int number_of_queens <- 2;
	int number_of_grids <- 8;
	list<Queen> queenList;
	int col <- 0;
	init
	{
		create Queen number: number_of_queens
		{
			location <- QueenGrid[col,0].location;
			col <- col + 1;
			
			//set the predecessor
			if(length(queenList) > 0)
			{
				
				self.predecessor <- queenList[length(queenList) - 1];
				
//				write "me"+self;
//				write "predecessor"+self.predecessor;

				//set the successor
				queenList[length(queenList) - 1].successor <- self;
			}
			
			
			queenList << self;
			
		}
		
		
		ask queenList[0] {
			self.column <- 0;
			self.row <- 0;
			self.placed <- true;
			do informSuccessorMyPosition();
		}
		
		
	}
	
}

grid QueenGrid width:  number_of_grids height:  number_of_grids {
	rgb color <- bool(((grid_x + grid_y) mod 2)) ? #black : #white;
}

species Queen skills:[fipa,moving]
{
	int column;
	int row;
	point myPosition <- nil;
	//to identify if myself is placed
	bool placed <- false;
	Queen predecessor <- nil;
	Queen successor <- nil;
	
	//to store the locations of grids which already have queens
	matrix filledGrids <- 0 as_matrix({ number_of_grids, number_of_grids});

	matrix possiblePosition <- 0 as_matrix({ number_of_grids, number_of_grids});
		
	action placeMyPosition
	{
		//find out possible Position of the matrix
		loop i from: 0 to: number_of_grids-1 step:1
		{
			loop j from: 0 to: number_of_grids-1 step:1
			{
				//first to find the grids that was filled
				if(filledGrids[i,j] = 1 )
				{
					possiblePosition[i,j] <- 1;
					loop x from: 0 to: number_of_grids-1 step:1
					{
						loop y from: 0 to: number_of_grids-1 step:1
						{
							//then fill in the column, row and diagonal line
							possiblePosition[x, j] <- 1;
							possiblePosition[i, y] <- 1;
							if((x-i) = (y-j))
							{
								possiblePosition[x,y] <- 1;
							}
						}
					}
				}
			
			}
		}
//		write possiblePosition;

		//use point list to generate a position list for randomly choice
		list<point> positionList;
		loop x from: 0 to: number_of_grids-1 step:1
		{
			loop y from: 0 to: number_of_grids-1 step:1
			{
				if(possiblePosition[x,y] = 0)
				{
					positionList << {x,y};
				}
			}
		}
		
		//randomly choose a possiblr position
		int temp <- rnd(0,length(positionList)-1);
		row <- positionList[temp].y;
		column <- positionList[temp].x;
		
	}
	
	action informSuccessorMyPosition
	{
		filledGrids[column, row] <- 1;
//		write filledGrids;	
		
		do start_conversation to: [successor] protocol: 'no-protocol' performative: 'inform' contents: [column, row];
	}
	
	reflex gotoMyPosition when: row != nil and column != nil and !placed
	{
		myPosition <- QueenGrid[column,row].location;
//		write "my grid: "+ self + " ["+row+", "+column+"]";
		do goto target: myPosition;
	}
	
	reflex reachMyPosition when: myPosition != nil and location distance_to myPosition < 0.2  and !placed
	{
		placed <- true;
		write "I arrived!";
	}
	
	reflex receivePredecessorPosition when: !(empty(informs))
	{
		Queen sender <- informs[0].sender;
		ask sender
		{	
			//self is the sender
			myself.filledGrids <- self.filledGrids;
			
		}
		do placeMyPosition;
	}
	
	aspect base
	{
		draw sphere(2) color: #yellow;
	}
}

experiment main type:gui
{
	output
	{
		display map type:opengl
		{
			
			species Queen aspect:base;
			grid QueenGrid lines:#black;
		}
	}
	
}